"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoolSystem = void 0;
const UE = require("ue");
const PublicAE_1 = require("./PublicAE");
const EntityPoolStore_1 = require("./EntityPoolStore");
const SystemPoolStore_1 = require("./SystemPoolStore");
const ECS_1 = require("../ECS");
const Decorator_1 = require("../../Decorator");
const Common_1 = require("../../Common");
class PoolSystem extends ECS_1.System {
    onCreateActorAction(action) {
        (0, Common_1.assert)(Common_1.GAME_INSTANCE !== undefined, 'GAME_INSTANCE is undefined');
        let store = EntityPoolStore_1.EntityPoolStore.getInstance();
        let reusableList = store.reusableEntities.get(action.ctor);
        if (reusableList === undefined || reusableList.length === 0) {
            // 没有可复用的actor则新创建一个
            let world = Common_1.GAME_INSTANCE.GetWorld();
            let actor = world.SpawnActor(action.ctor.StaticClass(), action.transform, UE.ESpawnActorCollisionHandlingMethod.Undefined, null, null);
            this.log(`A new Actor has been created: ${actor.GetName()}`);
            let guid = actor.ActorGuid.ToString();
            store.entitiesMap.set(guid, actor);
            this.pushToMapValueList(store.activeEntities, action.ctor, guid); // 加入已激活的实体列表
            return actor;
        }
        // 有可复用的actor则取出一个
        let guid = reusableList.shift();
        let actor = store.entitiesMap.get(guid);
        (0, Common_1.assert)(guid !== undefined && actor !== undefined, 'An error occurred in mapping the actor to the ID');
        actor.SetActorHiddenInGame(false);
        this.pushToMapValueList(store.activeEntities, action.ctor, guid); // 加入已激活的实体列表
        return actor;
    }
    onDestroyActorAction(action) {
        if (!this.hasActor(action.actor)) {
            this.warn(`Fail to destroy actor, ${action.actor.GetName()} does not exist in the entity pool`);
            return;
        }
        this.deleteActorFromActiveList(action.actor);
        this.recycleActorImpl(action.actor);
    }
    onDestroyAllActorAction(_) {
        let store = EntityPoolStore_1.EntityPoolStore.getInstance();
        store.entitiesMap.forEach((v, k) => {
            this.destroyActorImpl(v);
        });
    }
    onCreateSystemAction(action) {
        let systems = SystemPoolStore_1.SystemPoolStore.getInstance().systems;
        for (let v of systems) {
            if (v.constructor === action.ctor) {
                this.warn(`${action.ctor.name} has been created, you should not create it again`);
                return v;
            }
        }
        let system = new action.ctor();
        systems.push(system);
        return system;
    }
    onDestroySystemAction(action) {
        let store = SystemPoolStore_1.SystemPoolStore.getInstance();
        store.systems = store.systems.filter((s) => s.constructor !== action.ctor);
    }
    /**
     * 将actor从激活的列表中删除
     */
    deleteActorFromActiveList(actor) {
        let guid = actor.ActorGuid.ToString();
        let store = EntityPoolStore_1.EntityPoolStore.getInstance();
        let activeList = store.activeEntities.get(actor.constructor);
        if (activeList === undefined) {
            this.warn(`There is a mapping problem with the entity pool. id = ${guid}`);
            return;
        }
        // 更新激活的实体列表
        const filteredArray = activeList.filter((item) => item !== guid);
        if (filteredArray.length <= 0) {
            store.activeEntities.delete(actor.constructor);
        }
        else {
            store.activeEntities.set(actor.constructor, filteredArray);
        }
    }
    /**
     * 回收一个实体
     * @param {actor} actor
     */
    recycleActorImpl(actor) {
        actor.SetActorHiddenInGame(true); // 设置隐藏
        let store = EntityPoolStore_1.EntityPoolStore.getInstance();
        let guid = actor.ActorGuid.ToString();
        // 更新已被回收的实体列表
        let reusedList = store.reusableEntities.get(actor.constructor);
        if (reusedList === undefined) {
            store.reusableEntities.set(actor.constructor, [guid]);
        }
        else {
            reusedList.unshift(guid);
        }
        this.log(`Recycle Actor Impl execute, ${actor.GetName()} has been recycled`);
        if (reusedList && reusedList.length > store.capability) {
            // 在虚幻中删除该Actor
            let ableToDelete = reusedList.pop();
            this.destroyActorImpl(store.entitiesMap.get(ableToDelete));
        }
    }
    /**
     * 销毁一个实体
     * @param {actor} actor
     */
    destroyActorImpl(actor) {
        let store = EntityPoolStore_1.EntityPoolStore.getInstance();
        let reusableList = store.reusableEntities.get(actor.constructor);
        let activeList = store.activeEntities.get(actor.constructor);
        let guid = actor.ActorGuid.ToString();
        // 更新已被回收的实体列表
        if (reusableList) {
            const filteredArray = reusableList.filter((item) => item !== guid);
            store.reusableEntities.set(actor.constructor, filteredArray);
        }
        // 更新激活的实体列表
        if (activeList) {
            const filteredArray = activeList.filter((item) => item !== guid);
            store.activeEntities.set(actor.constructor, filteredArray);
        }
        store.entitiesMap.delete(guid);
        // 销毁在UE中销毁
        actor.Destroy();
        this.log(`Destroy Actor Impl execute, ${actor.GetName()} has been destroyed`);
    }
    /**
     * 检查实体池是否有这个实体
     *
     * @param {actor} actor
     * @returns {boolean}
     */
    hasActor(actor) {
        return EntityPoolStore_1.EntityPoolStore.getInstance().entitiesMap.has(actor.ActorGuid.ToString());
    }
    pushToMapValueList(map, key, val) {
        let valueList = map.get(key);
        if (valueList === undefined) {
            map.set(key, [val]);
        }
        else {
            valueList.push(val);
        }
    }
}
__decorate([
    (0, Decorator_1.listen)(PublicAE_1.CreateActorAction)
], PoolSystem.prototype, "onCreateActorAction", null);
__decorate([
    (0, Decorator_1.listen)(PublicAE_1.DestroyActorAction)
], PoolSystem.prototype, "onDestroyActorAction", null);
__decorate([
    (0, Decorator_1.listen)(PublicAE_1.DestroyAllActorAction)
], PoolSystem.prototype, "onDestroyAllActorAction", null);
__decorate([
    (0, Decorator_1.listen)(PublicAE_1.CreateSystemAction)
], PoolSystem.prototype, "onCreateSystemAction", null);
__decorate([
    (0, Decorator_1.listen)(PublicAE_1.DestroySystemAction)
], PoolSystem.prototype, "onDestroySystemAction", null);
exports.PoolSystem = PoolSystem;
//# sourceMappingURL=PoolSystem.js.map